package serializers

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Тестятся базовые типы - bool, int, float32, float64
func TestDeserialize_BasicTypes(t *testing.T) {
	s := &SerializerImpl{}
	tests := []struct {
		name           string
		value          []byte
		expectedResult any
		expectedType   reflect.Type
	}{
		{
			name:           "bool true",
			expectedResult: true,
			expectedType:   reflect.TypeOf(true),
			value:          []byte{0x1},
		},
		{
			name:           "bool false",
			expectedResult: false,
			expectedType:   reflect.TypeOf(true),
			value:          []byte{0x0},
		},
		{
			name:           "integer positive",
			expectedResult: 12345,
			expectedType:   reflect.TypeOf(1),
			value:          []byte{0xf2, 0xc0, 0x1},
		},
		{
			name:           "integer negative",
			expectedResult: -12345,
			expectedType:   reflect.TypeOf(1),
			value:          []byte{0xf1, 0xc0, 0x1},
		},
		{
			name:           "integer nil",
			expectedResult: 0,
			expectedType:   reflect.TypeOf(1),
			value:          []byte{0x0},
		},
		{
			name:           "float64 nil",
			expectedResult: float64(0),
			expectedType:   reflect.TypeOf(float64(0)),
			value:          []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			name:           "float64 positive",
			expectedResult: 1.234567890987654321,
			expectedType:   reflect.TypeOf(float64(0)),
			value:          []byte{0x1b, 0xbd, 0xc7, 0x42, 0xca, 0xc0, 0xf3, 0x3f},
		},
		{
			name:           "float64 negative",
			expectedResult: -1.234567890987654321,
			expectedType:   reflect.TypeOf(float64(0)),
			value:          []byte{0x1b, 0xbd, 0xc7, 0x42, 0xca, 0xc0, 0xf3, 0xbf},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual := reflect.New(test.expectedType).Elem()

			err := s.Deserialize(test.value, actual.Addr().Interface())
			require.NoError(t, err)

			assert.Equal(t, test.expectedResult, actual.Interface())
		})
	}
}

func TestDeserialize_Arrays(t *testing.T) {
	s := &SerializerImpl{}
	tests := []struct {
		name           string
		value          []byte
		expectedResult any
		expectedType   reflect.Type
	}{
		{
			name:           "int array empty",
			expectedResult: []int{},
			expectedType:   reflect.TypeOf([]int{1}),
			value:          []byte{0x0},
		},
		{
			name:           "int array nonempty",
			expectedResult: []int{1, 2, 3, 4},
			expectedType:   reflect.TypeOf([]int{1}),
			value:          []byte{0x8, 0x2, 0x2, 0x2, 0x4, 0x2, 0x6, 0x2, 0x8},
		},
		{
			name:           "int array nonempty with negative",
			expectedResult: []int{1, -2, 3, -4},
			expectedType:   reflect.TypeOf([]int{1}),
			value:          []byte{0x8, 0x2, 0x2, 0x2, 0x3, 0x2, 0x6, 0x2, 0x7},
		},
		{
			name:           "string empty",
			expectedResult: "",
			expectedType:   reflect.TypeOf("abcd"),
			value:          []byte{0x0},
		},
		{
			name:           "string non empty",
			expectedResult: "abcd",
			expectedType:   reflect.TypeOf("abcd"),
			value:          []byte{0x8, 0x61, 0x62, 0x63, 0x64},
		},
		{
			name:           "string non empty with digits",
			expectedResult: "abcd1234",
			expectedType:   reflect.TypeOf("abcd"),
			value: []byte{
				0x10, 0x61, 0x62, 0x63, 0x64, 0x31, 0x32, 0x33, 0x34,
			},
		},
		{
			name:           "large string non empty",
			expectedResult: "qwertyuiopasdfghjklzxcvbnm1234567890-=+_;'\"!@#$%^&*(){}[]",
			expectedType:   reflect.TypeOf("abcd"),
			value: []byte{
				0x72, 0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6f, 0x70, 0x61, 0x73, 0x64, 0x66, 0x67,
				0x68, 0x6a, 0x6b, 0x6c, 0x7a, 0x78, 0x63, 0x76, 0x62, 0x6e, 0x6d, 0x31, 0x32, 0x33, 0x34, 0x35,
				0x36, 0x37, 0x38, 0x39, 0x30, 0x2d, 0x3d, 0x2b, 0x5f, 0x3b, 0x27, 0x22, 0x21, 0x40, 0x23, 0x24,
				0x25, 0x5e, 0x26, 0x2a, 0x28, 0x29, 0x7b, 0x7d, 0x5b, 0x5d,
			},
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual := reflect.New(test.expectedType).Elem()

			err := s.Deserialize(test.value, actual.Addr().Interface())
			require.NoError(t, err)

			assert.Equal(t, test.expectedResult, actual.Interface())
		})
	}
}

func TestDeserialize_Struct(t *testing.T) {
	s := SerializerImpl{}
	tests := []struct {
		name           string
		value          []byte
		expectedResult any
		expectedType   reflect.Type
	}{
		{
			name: "basic_struct",
			value: []byte{
				0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x61, 0x62, 0x63, 0x64, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0xc, 0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa,
				0x7a, 0x78, 0x63, 0x76, 0x62,
			},
			expectedResult: Name{
				"abcd", "qwerty", "zxcvb",
			},
			expectedType: reflect.TypeOf(Name{}),
		},
		{
			name: "basic struct with empty string",
			value: []byte{
				0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x61, 0x62, 0x63, 0x64, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x7a, 0x78, 0x63, 0x76, 0x62,
			},
			expectedResult: Name{
				"abcd", "", "zxcvb",
			},
			expectedType: reflect.TypeOf(Name{}),
		},
		{
			name: "basic struct with empty strings",
			value: []byte{
				0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			},
			expectedResult: Name{
				"", "", "",
			},
			expectedType: reflect.TypeOf(Name{}),
		},
		{
			name: "one nested struct",
			value: []byte{
				0x2b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x71, 0x77, 0x65,
				0x72, 0x74, 0x79, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x61, 0x73, 0x64, 0x66, 0x67, 0x6, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x7a, 0x78, 0x63, 0x76, 0x62, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x3e, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
			},
			expectedResult: Person{
				Name: Name{
					"qwerty", "asdfg", "zxcvb",
				},
				Age:    31,
				Active: true,
			},
			expectedType: reflect.TypeOf(Person{}),
		},
		{
			name: "more nested struct",
			value: []byte{
				0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaa, 0x3, 0x45, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2b, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x71, 0x77, 0x65, 0x72, 0x74,
				0x79, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x61, 0x73, 0x64, 0x66, 0x67, 0x6, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0xa, 0x7a, 0x78, 0x63, 0x76, 0x62, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
			},
			expectedResult: User{
				UUID: 213,
				Person: Person{
					Name: Name{
						"qwerty", "asdfg", "zxcvb",
					},
					Age:    31,
					Active: true,
				},
			},
			expectedType: reflect.TypeOf(User{}),
		},
		{
			name: "array of nested struct",
			value: []byte{
				0x6, 0x92, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x71, 0x2, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x2, 0x77, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x65, 0x1, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x3c, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x92, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x4, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x61, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x73, 0x2, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x64, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x1, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x92, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x7a, 0x2,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x78, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x63, 0x1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
			},
			expectedResult: []User{
				{UUID: 1, Person: Person{Name: Name{"q", "w", "e"}, Age: 30, Active: true}},
				{UUID: 2, Person: Person{Name: Name{"a", "s", "d"}, Age: 35, Active: false}},
				{UUID: 3, Person: Person{Name: Name{"z", "x", "c"}, Age: 13, Active: true}},
			},
			expectedType: reflect.TypeOf([]User{}),
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual := reflect.New(test.expectedType).Elem()

			err := s.Deserialize(test.value, actual.Addr().Interface())
			require.NoError(t, err)

			assert.Equal(t, test.expectedResult, actual.Interface())
		})
	}
}
