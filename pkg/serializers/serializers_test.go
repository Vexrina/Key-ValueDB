package serializers

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Тестятся базовые типы - bool, int, float32, float64
func TestSerialize_BasicTypes(t *testing.T) {
	s := &SerializerImpl{}
	tests := []struct {
		name           string
		value          any
		expectedResult []byte
	}{
		{
			name:           "bool true",
			value:          true,
			expectedResult: []byte{0x1},
		},
		{
			name:           "bool false",
			value:          false,
			expectedResult: []byte{0x0},
		},
		{
			name:  "integer positive",
			value: 12345,
			expectedResult: []byte{0xf2, 0xc0, 0x1},
		},
		{
			name:  "integer negative",
			value: -12345,
			expectedResult: []byte{0xf1, 0xc0, 0x1},
		},
		{
			name:  "integer nil",
			value: 0,
			expectedResult: []byte{0x0},
		},
		{
			name:           "float32 nil",
			value:          float32(0),
			expectedResult: []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			name:           "float64 nil",
			value:          float64(0),
			expectedResult: []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			name:           "float32 positive",
			value:          float32(1.234567890987654321),
			expectedResult: []byte{0x0, 0x0, 0x0, 0x40, 0xca, 0xc0, 0xf3, 0x3f},
		},
		{
			name:           "float64 positive",
			value:          1.234567890987654321,
			expectedResult: []byte{0x1b, 0xbd, 0xc7, 0x42, 0xca, 0xc0, 0xf3, 0x3f},
		},
		{
			name:           "float32 negative",
			value:          float32(-1.234567890987654321),
			expectedResult: []byte{0x0, 0x0, 0x0, 0x40, 0xca, 0xc0, 0xf3, 0xbf},
		},
		{
			name:           "float64 negative",
			value:          -1.234567890987654321,
			expectedResult: []byte{0x1b, 0xbd, 0xc7, 0x42, 0xca, 0xc0, 0xf3, 0xbf},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual, err := s.Serialize(test.value)
			require.NoError(t, err)
			assert.Equal(t, test.expectedResult, actual)
		})
	}
}

// Строка есмь массив символов/байтов, поэтому тестится тут
func TestSerialize_Arrays(t *testing.T) {
	s := &SerializerImpl{}
	tests := []struct {
		name           string
		value          any
		expectedResult []byte
	}{
		{
			name:           "int array empty",
			value:          []int{},
			expectedResult: []byte{0x0},
		},
		{
			name:           "int array nonempty",
			value:          []int{1, 2, 3, 4},
			expectedResult: []byte{0x8, 0x2, 0x2, 0x2, 0x4, 0x2, 0x6, 0x2, 0x8},
		},
		{
			name:           "int array nonempty with negative",
			value:          []int{1, -2, 3, -4},
			expectedResult: []byte{0x8, 0x2, 0x2, 0x2, 0x3, 0x2, 0x6, 0x2, 0x7},
		},
		{
			name:           "string empty",
			value:          "",
			expectedResult: []byte{0x0},
		},
		{
			name:           "string non empty",
			value:          "abcd",
			expectedResult: []byte{0x8, 0x61, 0x62, 0x63, 0x64},
		},
		{
			name:  "string non empty with digits",
			value: "abcd1234",
			expectedResult: []byte{
				0x10, 0x61, 0x62, 0x63, 0x64, 0x31, 0x32, 0x33, 0x34,
			},
		},
		{
			name:  "large string non empty",
			value: "qwertyuiopasdfghjklzxcvbnm1234567890-=+_;'\"!@#$%^&*(){}[]",
			expectedResult: []byte{
				0x72, 0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6f, 0x70, 0x61, 0x73, 0x64, 0x66, 0x67,
				0x68, 0x6a, 0x6b, 0x6c, 0x7a, 0x78, 0x63, 0x76, 0x62, 0x6e, 0x6d, 0x31, 0x32, 0x33, 0x34, 0x35,
				0x36, 0x37, 0x38, 0x39, 0x30, 0x2d, 0x3d, 0x2b, 0x5f, 0x3b, 0x27, 0x22, 0x21, 0x40, 0x23, 0x24,
				0x25, 0x5e, 0x26, 0x2a, 0x28, 0x29, 0x7b, 0x7d, 0x5b, 0x5d,
			},
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual, err := s.Serialize(test.value)
			require.NoError(t, err)
			assert.Equal(t, test.expectedResult, actual)
		})
	}
}

// тестим структурки в разных видах
func TestSerialize_Struct(t *testing.T) {
	s := SerializerImpl{}
	tests := []struct {
		name           string
		value          any
		expectedResult []byte
	}{
		{
			name: "basic_struct",
			value: Name{
				"abcd", "qwerty", "zxcvb",
			},
			expectedResult: []byte{
				0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x61, 0x62, 0x63, 0x64, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0xc, 0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa,
				0x7a, 0x78, 0x63, 0x76, 0x62,
			},
		},
		{
			name: "basic struct with empty string",
			value: Name{
				"abcd", "", "zxcvb",
			},
			expectedResult: []byte{
				0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x61, 0x62, 0x63, 0x64, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x7a, 0x78, 0x63, 0x76, 0x62,
			},
		},
		{
			name: "basic struct with empty strings",
			value: Name{
				"", "", "",
			},
			expectedResult: []byte{
				0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			},
		},
		{
			name: "one nested struct",
			value: Person{
				Name: Name{
					"qwerty", "asdfg", "zxcvb",
				},
				Age:    31,
				Active: true,
			},
			expectedResult: []byte{
				0x2b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x71, 0x77, 0x65,
				0x72, 0x74, 0x79, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x61, 0x73, 0x64, 0x66, 0x67, 0x6, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x7a, 0x78, 0x63, 0x76, 0x62, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x3e, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
			},
		},
		{
			name: "more nested struct",
			value: User{
				UUID: 213,
				Person: Person{
					Name: Name{
						"qwerty", "asdfg", "zxcvb",
					},
					Age:    31,
					Active: true,
				},
			},
			expectedResult: []byte{
				0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaa, 0x3, 0x45, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2b, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x71, 0x77, 0x65, 0x72, 0x74,
				0x79, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x61, 0x73, 0x64, 0x66, 0x67, 0x6, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0xa, 0x7a, 0x78, 0x63, 0x76, 0x62, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
			},
		},
		{
			name: "array of nested struct",
			value: []User{
				{UUID: 1, Person: Person{Name: Name{"q", "w", "e"}, Age: 30, Active: true}},
				{UUID: 2, Person: Person{Name: Name{"a", "s", "d"}, Age: 35, Active: false}},
				{UUID: 3, Person: Person{Name: Name{"z", "x", "c"}, Age: 13, Active: true}},
			},
			expectedResult: []byte{
				0x6, 0x92, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x71, 0x2, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x2, 0x77, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x65, 0x1, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x3c, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x92, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x4, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x61, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x73, 0x2, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x64, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x1, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x92, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x38, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x1e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x7a, 0x2,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x78, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x63, 0x1, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
			},
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual, err := s.Serialize(test.value)
			require.NoError(t, err)
			assert.Equal(t, test.expectedResult, actual)
		})
	}
}

// не уверен, в какой конкретно тип можно засунуть мапу, пусть будет тут
func TestSerialize_Map(t *testing.T) {
	s := &SerializerImpl{}
	tests := []struct {
		name           string
		value          any
		expectedResult []byte
		expectedType   reflect.Type
	}{
		{
			name:         "map empty",
			value:        map[string]int{},
			expectedType: reflect.TypeOf(map[string]int{}),
		},
		{
			name:         "map of any empty",
			value:        map[string]any{},
			expectedType: reflect.TypeOf(map[string]any{}),
		},
		{
			name:         "map any of any empty",
			value:        map[any]any{},
			expectedType: reflect.TypeOf(map[any]any{}),
		},
		{
			name: "map not empty",
			value: map[string]int{
				"a": 1, "b": 2, "c": 3, "d": 4,
			},
			expectedType: reflect.TypeOf(map[string]int{}),
		},
		{
			name: "map of any not empty",
			value: map[string]any{
				"a": 1, "b": 2.1, "c": "3",
			},
			expectedType: reflect.TypeOf(map[string]any{}),
		},
		{
			name: "map any of any not empty",
			value: map[any]any{
				"a": 1, 1: 2.1, "c": "3",
			},
			expectedType: reflect.TypeOf(map[any]any{}),
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			bytes, err := s.Serialize(test.value)
			require.NoError(t, err)

			/*
				не могу просто взять и проверить байты, т.к. порядок ключей недетерменированный
				сверяю сразу с десериализацией.
			*/

			actual := reflect.New(test.expectedType).Elem()
			err = s.Deserialize(bytes, actual.Addr().Interface())
			require.NoError(t, err)

			assert.Equal(t, test.value, actual.Interface())
		})
	}
}
